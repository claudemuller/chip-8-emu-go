package hardware

// CPU emulates the processor.
type CPU struct {
    Renderer *Renderer
    memory [4096]uint8
}

// NewCPU is a factory that returns a new CPU.
func NewCPU(r *Renderer) *CPU {
    return &CPU{
        Renderer: r,
    }
}

// LoadSpritesIntoMemory loads the ROM's bytes into memory.
func (c *CPU) LoadSpritesIntoMemory() error {
    // Array of hex values for the 16 5-byte sprites (0-F) - http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#2.4
    sprites := [80]uint8{
        0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
        0x20, 0x60, 0x20, 0x20, 0x70, // 1
        0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
        0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
        0x90, 0x90, 0xF0, 0x10, 0x10, // 4
        0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
        0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
        0xF0, 0x10, 0x20, 0x40, 0x40, // 7
        0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
        0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
        0xF0, 0x90, 0xF0, 0x90, 0x90, // A
        0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
        0xF0, 0x80, 0x80, 0x80, 0xF0, // C
        0xE0, 0x90, 0x90, 0x90, 0xE0, // D
        0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
        0xF0, 0x80, 0xF0, 0x80, 0x80, // F
    };

    // The sprites can be loaded into interpreter memory space (0x000 - 0x1FFF).
    for i, s := range sprites {
        c.memory[i] = s
    }

    return nil
}

// Cycle executes an instruction.
func (c *CPU) Cycle() {
}
